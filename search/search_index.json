{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"mheatmap","text":"<p>A Python package for advanced heatmap visualization and matrix analysis, featuring mosaic/proportional heatmaps, confusion matrix post-processing, and spectral reordering capabilities.</p>"},{"location":"index.html#features","title":"\ud83d\ude80 Features","text":"<ul> <li> <p>Mosaic Heatmap   Visualize matrix values with proportionally-sized cells. </p> </li> <li> <p>Automatic Model Calibration (AMC)   Align, Mask, and Confusion\u2014an algorithm for post-processing confusion matrices.</p> </li> <li> <p>Spectral Reordering   Reorder matrices based on spectral analysis.   </p> </li> <li> <p>RMS (Reverse Merge/Split) Analysis   Perform advanced permutation analysis to explore matrix structures. </p> </li> </ul>"},{"location":"index.html#contributing","title":"\ud83d\udee0 Contributing","text":"<p>We welcome contributions to improve mheatmap! Please follow these steps:</p> <ol> <li>Fork the repository</li> <li>Create a new branch (<code>feature-branch</code>)</li> <li>Commit your changes</li> <li>Open a pull request</li> </ol>"},{"location":"index.html#license","title":"\ud83d\udcdd License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"install.html","title":"\ud83d\udce6 Installation","text":""},{"location":"install.html#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install mheatmap\n</code></pre>"},{"location":"install.html#install-from-source","title":"Install from source","text":"<pre><code>git clone https://github.com/qqgjyx/mheatmap.git # (1) \ncd mheatmap\npip install .\n</code></pre>"},{"location":"api/index.html","title":"API Reference","text":""},{"location":"api/index.html#visualization","title":"Visualization","text":"Module Description <code>mosaic_heatmap</code> Create heatmaps with proportionally-sized cells based on matrix values"},{"location":"api/index.html#matrix-analysis","title":"Matrix Analysis","text":"Module Description <code>amc_postprocess</code> Post-process confusion matrices using the Automatic Model Calibration (AMC) algorithm <code>rms_permute</code> Analyze matrix structures using Reverse Merge/Split permutation analysis"},{"location":"api/index.html#graph","title":"Graph","text":"Module Description <code>graph</code> Graph-based permutation"},{"location":"api/amc-postprocess.html","title":"<code>amc_postprocess</code>","text":"<p><code>amc_postprocess(pred_, gt)</code></p> <p>Post-process predictions by aligning labels and computing confusion matrix. This function performs Align-Mask-Confusion (AMC) post-processing on predicted labels to optimally align them with ground truth labels and compute the confusion matrix.</p> <p>Parameters:</p> Name Type Description Default <code>pred_</code> <code>ndarray</code> <p>Array of predicted labels</p> required <code>gt</code> <code>ndarray</code> <p>Array of ground truth labels</p> required <p>Returns:</p> Name Type Description <code>aligned_pred</code> <code>ndarray</code> <p>Predictions with labels optimally aligned to ground truth</p> <code>conf_mat</code> <code>ndarray</code> <p>Confusion matrix computed from aligned predictions</p> <code>conf_mat_labels</code> <code>ndarray</code> <p>Union of unique labels from ground truth and predictions</p> Notes <p>The function assumes zero values represent unlabeled data points. Prediction labels are automatically shifted by +1 during processing to avoid conflicts with the zero-value convention for unlabeled points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; # Example with 3 classes and some unlabeled points (zeros)\n&gt;&gt;&gt; gt = np.array([1, 2, 0, 3, 1, 2])\n&gt;&gt;&gt; pred = np.array([2, 3, 0, 1, 2, 3])\n&gt;&gt;&gt; aligned_pred, conf_mat, labels = amc_postprocess(pred, gt)\n&gt;&gt;&gt; print(\"Aligned predictions:\", aligned_pred)\nAligned predictions: [1 2 0 3 1 2]\n&gt;&gt;&gt; print(\"Confusion matrix:\")\n&gt;&gt;&gt; print(conf_mat)\n[[2 0 0]\n [0 2 0]\n [0 0 1]]\n&gt;&gt;&gt; print(\"Labels:\", labels)\nLabels: [1 2 3]\n</code></pre> Source code in <code>mheatmap/_amc_postprocess.py</code> <pre><code>def amc_postprocess(\n    pred_: np.ndarray, gt: np.ndarray\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"`amc_postprocess(pred_, gt)`\n\n    Post-process predictions by aligning labels and computing confusion matrix.\n    This function performs Align-Mask-Confusion (AMC) post-processing on predicted labels\n    to optimally align them with ground truth labels and compute the confusion matrix.\n\n    Parameters\n    ----------\n    pred_ : np.ndarray\n        Array of predicted labels\n    gt : np.ndarray\n        Array of ground truth labels\n\n    Returns\n    -------\n    aligned_pred : np.ndarray\n        Predictions with labels optimally aligned to ground truth\n\n    conf_mat : np.ndarray\n        Confusion matrix computed from aligned predictions\n\n    conf_mat_labels : np.ndarray\n        Union of unique labels from ground truth and predictions\n\n    Notes\n    -----\n    The function assumes zero values represent unlabeled data points. Prediction\n    labels are automatically shifted by +1 during processing to avoid conflicts\n    with the zero-value convention for unlabeled points.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; # Example with 3 classes and some unlabeled points (zeros)\n    &gt;&gt;&gt; gt = np.array([1, 2, 0, 3, 1, 2])\n    &gt;&gt;&gt; pred = np.array([2, 3, 0, 1, 2, 3])\n    &gt;&gt;&gt; aligned_pred, conf_mat, labels = amc_postprocess(pred, gt)\n    &gt;&gt;&gt; print(\"Aligned predictions:\", aligned_pred)\n    Aligned predictions: [1 2 0 3 1 2]\n    &gt;&gt;&gt; print(\"Confusion matrix:\")\n    &gt;&gt;&gt; print(conf_mat)\n    [[2 0 0]\n     [0 2 0]\n     [0 0 1]]\n    &gt;&gt;&gt; print(\"Labels:\", labels)\n    Labels: [1 2 3]\n    \"\"\"\n    amc = _AMCPostprocess(pred_, gt)\n    pr = amc.get_aligned_pred()\n    C = amc.get_C()\n    C_labels = amc.get_C_labels()\n    return pr, C, C_labels\n</code></pre> <p><code>mask_zeros_from_gt(labels, gt, mode=\"labels\")</code></p> <p>Mask unlabeled points (zeros) from ground truth labels.</p> <p>This function handles both 1D and 2D label arrays by masking points that correspond to zeros in the ground truth labels. For image mode, it preserves the 2D spatial structure of the input.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>ndarray</code> <p>Labels to be masked. Can be either: - 1D array of shape (n_samples,) - 2D array of shape (height, width) for image mode</p> required <code>gt</code> <code>ndarray</code> <p>Ground truth labels of shape (n_samples,) containing zeros for unlabeled points</p> required <code>mode</code> <code>(labels, image)</code> <p>Operating mode: - 'labels': Returns 1D masked array - 'image': Returns 2D masked array preserving spatial structure</p> <code>'labels'</code> <p>Returns:</p> Type Description <code>MaskedArray</code> <p>Masked array where unlabeled points (zeros in ground truth) are masked. Shape matches input labels.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If labels dimensions don't match the mode or ground truth shape</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; # Example with 1D labels\n&gt;&gt;&gt; labels = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; gt = np.array([1, 0, 3, 0, 5])\n&gt;&gt;&gt; masked = mask_zeros_from_gt(labels, gt)\n&gt;&gt;&gt; print(masked)\n[1 3 5]\n</code></pre> <pre><code>&gt;&gt;&gt; # Example with 2D image labels\n&gt;&gt;&gt; img_labels = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; img_gt = np.array([[1, 0], [3, 0]])\n&gt;&gt;&gt; masked_img = mask_zeros_from_gt(img_labels, img_gt, mode='image')\n&gt;&gt;&gt; print(masked_img)\n[[1 --]\n [3 --]]\n</code></pre> Source code in <code>mheatmap/_amc_postprocess.py</code> <pre><code>def mask_zeros_from_gt(labels, gt, mode=\"labels\"):\n    \"\"\"`mask_zeros_from_gt(labels, gt, mode=\"labels\")`\n\n    Mask unlabeled points (zeros) from ground truth labels.\n\n    This function handles both 1D and 2D label arrays by masking points that correspond\n    to zeros in the ground truth labels. For image mode, it preserves the 2D spatial\n    structure of the input.\n\n    Parameters\n    ----------\n    labels : numpy.ndarray\n        Labels to be masked. Can be either:\n        - 1D array of shape (n_samples,)\n        - 2D array of shape (height, width) for image mode\n    gt : numpy.ndarray\n        Ground truth labels of shape (n_samples,) containing zeros for unlabeled points\n    mode : {'labels', 'image'}, default='labels'\n        Operating mode:\n        - 'labels': Returns 1D masked array\n        - 'image': Returns 2D masked array preserving spatial structure\n\n    Returns\n    -------\n    numpy.ma.MaskedArray\n        Masked array where unlabeled points (zeros in ground truth) are masked.\n        Shape matches input labels.\n\n    Raises\n    ------\n    ValueError\n        If labels dimensions don't match the mode or ground truth shape\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; # Example with 1D labels\n    &gt;&gt;&gt; labels = np.array([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; gt = np.array([1, 0, 3, 0, 5])\n    &gt;&gt;&gt; masked = mask_zeros_from_gt(labels, gt)\n    &gt;&gt;&gt; print(masked)\n    [1 3 5]\n\n    &gt;&gt;&gt; # Example with 2D image labels\n    &gt;&gt;&gt; img_labels = np.array([[1, 2], [3, 4]])\n    &gt;&gt;&gt; img_gt = np.array([[1, 0], [3, 0]])\n    &gt;&gt;&gt; masked_img = mask_zeros_from_gt(img_labels, img_gt, mode='image')\n    &gt;&gt;&gt; print(masked_img)\n    [[1 --]\n     [3 --]]\n    \"\"\"\n    if mode == \"image\":\n        if len(labels.shape) != 2:\n            raise ValueError(\"Labels must be 2D array for image mode\")\n\n        gt_image = gt.reshape(labels.shape) if labels.shape != gt.shape else gt\n        mask = gt_image != 0\n        return np.ma.masked_where(~mask, labels)\n\n    elif mode == \"labels\":\n        if labels.shape != gt.shape:\n            labels = labels.reshape(-1)\n            if labels.shape != gt.shape:\n                raise ValueError(\n                    \"Labels shape must match ground truth after flattening\"\n                )\n\n        mask = gt != 0\n        return labels[mask]\n\n    else:\n        raise ValueError(\"Mode must be either 'labels' or 'image'\")\n</code></pre>"},{"location":"api/graph.html","title":"<code>graph</code>","text":"<p><code>spectral_permute(B, labels, mode='tw')</code></p> <p>Perform spectral reordering of a confusion matrix using graph Laplacian eigenvectors.</p> <p>This function implements spectral reordering to reveal block structures in confusion matrices by analyzing the eigenvectors of the graph Laplacian. The reordering is based on the Fiedler vector (eigenvector corresponding to the second smallest eigenvalue), which provides an optimal ordering that groups similar classes together.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>ndarray</code> <p>Input confusion matrix to be reordered, shape (n_classes, n_classes)</p> required <code>labels</code> <code>ndarray</code> <p>Class labels corresponding to matrix rows/columns, shape (n_classes,)</p> required <code>mode</code> <code>(tw, fiedler)</code> <p>Spectral reordering method: - 'tw': Use two-walk Laplacian for bipartite graph analysis - 'fiedler': Use standard Fiedler vector approach</p> <code>'tw'</code> <p>Returns:</p> Name Type Description <code>reordered_cm</code> <code>ndarray</code> <p>Reordered confusion matrix with revealed block structure</p> <code>reordered_labels</code> <code>ndarray</code> <p>Class labels reordered to match the permuted matrix rows/columns</p> See Also <p>mheatmap.rms_permute : Alternative reordering using merge/split patterns mheatmap.amc_postprocess : Post-processing tools for confusion matrices mheatmap.graph.two_walk_laplacian : Two-walk Laplacian computation</p> Notes <p>The algorithm proceeds in the following steps: 1. For mode='tw':     - Constructs two-walk Laplacian capturing bipartite graph structure     - Handles isolated vertices automatically 2. For mode='fiedler':     - Computes standard graph Laplacian L = D - A 3. Finds Fiedler vector (second smallest eigenvector) 4. Sorts vertices based on Fiedler vector components 5. Applies resulting permutation to matrix and labels</p> References <p>.. [1] Fiedler, M. (1973). Algebraic connectivity of graphs.        Czechoslovak Mathematical Journal, 23(2), 298-305. .. [2] Sun, X. (2024). Matrix, Graph and Network Analysis.        CS521 Course Notes, Duke University.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; conf_mat = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\n&gt;&gt;&gt; labels = np.array(['A', 'B', 'C'])\n&gt;&gt;&gt; reordered_mat, reordered_labs = spectral_permute(conf_mat, labels)\n</code></pre> Source code in <code>mheatmap/graph/_spectral_permute.py</code> <pre><code>def spectral_permute(\n    B: np.ndarray, labels: np.ndarray, mode: str = \"tw\"\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"`spectral_permute(B, labels, mode='tw')`\n\n    Perform spectral reordering of a confusion matrix using graph Laplacian eigenvectors.\n\n    This function implements spectral reordering to reveal block structures in confusion matrices\n    by analyzing the eigenvectors of the graph Laplacian. The reordering is based on the Fiedler\n    vector (eigenvector corresponding to the second smallest eigenvalue), which provides an optimal\n    ordering that groups similar classes together.\n\n    Parameters\n    ----------\n    B : np.ndarray\n        Input confusion matrix to be reordered, shape (n_classes, n_classes)\n    labels : np.ndarray\n        Class labels corresponding to matrix rows/columns, shape (n_classes,)\n    mode : {'tw', 'fiedler'}, default='tw'\n        Spectral reordering method:\n        - 'tw': Use two-walk Laplacian for bipartite graph analysis\n        - 'fiedler': Use standard Fiedler vector approach\n\n    Returns\n    -------\n    reordered_cm : np.ndarray\n        Reordered confusion matrix with revealed block structure\n    reordered_labels : np.ndarray\n        Class labels reordered to match the permuted matrix rows/columns\n\n    See Also\n    --------\n    mheatmap.rms_permute : Alternative reordering using merge/split patterns\n    mheatmap.amc_postprocess : Post-processing tools for confusion matrices\n    mheatmap.graph.two_walk_laplacian : Two-walk Laplacian computation\n\n    Notes\n    -----\n    The algorithm proceeds in the following steps:\n    1. For mode='tw':\n        - Constructs two-walk Laplacian capturing bipartite graph structure\n        - Handles isolated vertices automatically\n    2. For mode='fiedler':\n        - Computes standard graph Laplacian L = D - A\n    3. Finds Fiedler vector (second smallest eigenvector)\n    4. Sorts vertices based on Fiedler vector components\n    5. Applies resulting permutation to matrix and labels\n\n    References\n    ----------\n    .. [1] Fiedler, M. (1973). Algebraic connectivity of graphs.\n           Czechoslovak Mathematical Journal, 23(2), 298-305.\n    .. [2] Sun, X. (2024). Matrix, Graph and Network Analysis.\n           CS521 Course Notes, Duke University.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; conf_mat = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\n    &gt;&gt;&gt; labels = np.array(['A', 'B', 'C'])\n    &gt;&gt;&gt; reordered_mat, reordered_labs = spectral_permute(conf_mat, labels)\n    \"\"\"\n    rows, cols = B.shape\n\n    if mode == \"fiedler\":\n        # Compute standard graph Laplacian L = D - A\n        D = np.diag(np.sum(B, axis=1))\n        L = D - B\n\n        # Get eigendecomposition and find Fiedler vector\n        eigenvalues, eigenvectors = eigh(L)\n        nonzero_idx = np.where(np.abs(eigenvalues) &gt; 1e-10)[0][0]\n        fiedler_vector = eigenvectors[:, nonzero_idx]\n\n        # Visualize eigenspectrum\n        plot_eigen(eigenvalues, eigenvectors)\n\n        # Sort vertices based on Fiedler vector\n        sorted_rows_indices = np.argsort(fiedler_vector)\n        sorted_cols_indices = sorted_rows_indices\n\n    elif mode == \"tw\":\n        # Handle isolated vertices\n        B, labels = _put_zero_rows_cols_tail(B, labels)\n        B_sub, Bsub_rows, Bsub_cols = _get_B_sub(B)\n\n        # Compute two-walk Laplacian and its eigendecomposition\n        L = two_walk_laplacian(B_sub)\n        eigenvalues, eigenvectors = eigh(L)\n\n        # Get Fiedler vector for spectral ordering\n        nonzero_idx = np.where(np.abs(eigenvalues) &gt; 1e-10)[0][0]\n        fiedler_vector = eigenvectors[:, nonzero_idx]\n\n        # Visualize eigenspectrum\n        plot_eigen(eigenvalues, eigenvectors)\n\n        # Get permutation from Fiedler vector\n        p_Asub = np.argsort(fiedler_vector)\n\n        # Map bipartite permutation to matrix dimensions\n        sorted_rows_indices, sorted_cols_indices = copermute_from_bipermute(\n            [rows, cols], Bsub_rows, Bsub_cols, p_Asub\n        )\n\n    # Apply permutation to get reordered matrix and labels\n    reordered_B = B[sorted_rows_indices, :][:, sorted_cols_indices]\n    reordered_labels = labels[sorted_rows_indices]\n\n    # Visualize result\n    plot_bipartite_confusion_matrix(reordered_B, reordered_labels)\n\n    return reordered_B, reordered_labels\n</code></pre> <p><code>copermute_from_bipermute(B_sizes, B_subrows, B_subcols, p_Asub)</code></p> <p>Copermute from bi-permutation.</p> <p>Renders row permutation and column permutation of matrix B according to a co-permutation of a submatrix Bsub via a bi-permutation in its symmetric embedding:     Asub = [[0, Bsub], [Bsub.T, 0]]</p> <p>Parameters:</p> Name Type Description Default <code>B_sizes</code> <code>array_like</code> <p>A 1x2 array containing the dimensions of matrix B: [nrows, ncols]</p> required <code>B_subrows</code> <code>array_like</code> <p>Row indices defining the submatrix Bsub, nrBsub x 1 integer array where nrBsub &lt;= nrB</p> required <code>B_subcols</code> <code>array_like</code> <p>Column indices defining the submatrix Bsub, ncBsub x 1 integer array where ncBsub &lt;= ncB</p> required <code>p_Asub</code> <code>array_like</code> <p>Permutation vector for the symmetric embedding of Bsub, (nr+nc)x1 integer array</p> required <p>Returns:</p> Type Description <code>tuple</code> <ul> <li>p_Brows : Row permutation vector for matrix B, Bsizes[0]x1</li> <li>p_Bcols : Column permutation vector for matrix B, Bsizes[1]x1</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; m, n = 5, 4  # matrix dimensions\n&gt;&gt;&gt; B_sizes = [m, n]\n&gt;&gt;&gt; # Use entire matrix as submatrix\n&gt;&gt;&gt; p_Brows, p_Bcols = copermute_from_bipermute(\n...     B_sizes,\n...     np.arange(1,m+1),\n...     np.arange(1,n+1),\n...     np.random.permutation(m+n)+1\n... )\n</code></pre> Notes <p>Revision of recover_nonsymmetric_perm.m All variables renamed to be self-evident + additional documentation Nov. 22, 2024</p> Authors <ul> <li>Dimitris Floros dimitrios.floros@duke.edu</li> <li>Xiaobai Sun</li> <li>Juntang Wang</li> </ul> Source code in <code>mheatmap/graph/_copermute_from_bipermute.py</code> <pre><code>def copermute_from_bipermute(\n    B_sizes: list[int], B_subrows: np.ndarray, B_subcols: np.ndarray, p_Asub: np.ndarray\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"`copermute_from_bipermute(B_sizes, B_subrows, B_subcols, p_Asub)`\n\n    Copermute from bi-permutation.\n\n    Renders row permutation and column permutation of matrix B according to a co-permutation\n    of a submatrix Bsub via a bi-permutation in its symmetric embedding:\n        Asub = [[0, Bsub], [Bsub.T, 0]]\n\n    Parameters\n    ----------\n    B_sizes : array_like\n        A 1x2 array containing the dimensions of matrix B: [nrows, ncols]\n    B_subrows : array_like\n        Row indices defining the submatrix Bsub, nrBsub x 1 integer array where nrBsub &lt;= nrB\n    B_subcols : array_like\n        Column indices defining the submatrix Bsub, ncBsub x 1 integer array where ncBsub &lt;= ncB\n    p_Asub : array_like\n        Permutation vector for the symmetric embedding of Bsub, (nr+nc)x1 integer array\n\n    Returns\n    -------\n    tuple\n        - p_Brows : Row permutation vector for matrix B, Bsizes[0]x1\n        - p_Bcols : Column permutation vector for matrix B, Bsizes[1]x1\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; m, n = 5, 4  # matrix dimensions\n    &gt;&gt;&gt; B_sizes = [m, n]\n    &gt;&gt;&gt; # Use entire matrix as submatrix\n    &gt;&gt;&gt; p_Brows, p_Bcols = copermute_from_bipermute(\n    ...     B_sizes,\n    ...     np.arange(1,m+1),\n    ...     np.arange(1,n+1),\n    ...     np.random.permutation(m+n)+1\n    ... )\n\n    Notes\n    -----\n    Revision of recover_nonsymmetric_perm.m\n    All variables renamed to be self-evident + additional documentation\n    Nov. 22, 2024\n\n    Authors\n    -------\n    - Dimitris Floros &lt;dimitrios.floros@duke.edu&gt;\n    - Xiaobai Sun\n    - Juntang Wang\n    \"\"\"\n    nr_B = B_sizes[0]\n    nc_B = B_sizes[1]\n\n    nr_Bsub = len(B_subrows)\n    nc_Bsub = len(B_subcols)\n\n    # Set the markers for bipartite-embedding of Bsub: 1 for rows; 2 for columns\n    bi_marker = np.concatenate(\n        [np.ones(nr_Bsub, dtype=int), 2 * np.ones(nc_Bsub, dtype=int)]\n    )\n    bi_marker = bi_marker[p_Asub]\n\n    # Separate row and column indices in the bi-permutation\n    p_r = p_Asub[bi_marker == 1]\n    p_c = p_Asub[bi_marker == 2] - nr_Bsub\n\n    # Permute the given indices at input\n    pr_Bsub = B_subrows[p_r]\n    pc_Bsub = B_subcols[p_c]\n\n    # Render co-permutation in B: place Bsub first, the remaining to the end\n    p_Brows = np.concatenate([pr_Bsub, np.setdiff1d(np.arange(0, nr_B), pr_Bsub)])\n\n    p_Bcols = np.concatenate([pc_Bsub, np.setdiff1d(np.arange(0, nc_B), pc_Bsub)])\n\n    return p_Brows, p_Bcols\n</code></pre> <p><code>two_walk_laplacia(B_sub, alpha=1)</code></p> <p>Compute the two-walk Laplacian matrix of a bipartite graph.</p> <p>For a bipartite graph with biadjacency matrix B, constructs the two-walk Laplacian by first forming the two-walk adjacency matrix A_tw and then computing L_tw = D_tw - A_tw, where D_tw is the diagonal degree matrix.</p> <p>Parameters:</p> Name Type Description Default <code>B_sub</code> <code>ndarray</code> <p>Biadjacency matrix of shape (m, n) representing connections between two vertex sets</p> required <code>alpha</code> <code>float</code> <p>Scaling factor for the adjacency matrix term in the Laplacian computation</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>L_tw</code> <code>ndarray</code> <p>Two-walk Laplacian matrix of shape (m+n, m+n)</p> <code>Bsub_rows</code> <code>ndarray</code> <p>Indices of non-zero rows in the input matrix</p> <code>Bsub_cols</code> <code>ndarray</code> <p>Indices of non-zero columns in the input matrix</p> Notes <p>The two-walk adjacency matrix A_tw has the block structure:     [BB^T    \u03b1B  ]     [\u03b1B^T   B^TB ]</p> <p>where \u03b1 is the scaling factor controlling the influence of direct connections.</p> <p>The implementation automatically handles isolated vertices by removing rows/columns with all zeros before computation. The returned indices enable mapping back to the original matrix dimensions.</p> References <p>.. [1] Sun, X. (2024). Graph Algorithms for Matrix Analysis. CS521 Course Notes,        Duke University.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; B = np.array([[1, 0], [1, 1]])\n&gt;&gt;&gt; L_tw, rows, cols = two_walk_laplacian(B)\n&gt;&gt;&gt; print(L_tw.shape)\n(4, 4)\n</code></pre> Source code in <code>mheatmap/graph/_two_walk_laplacian.py</code> <pre><code>def two_walk_laplacian(\n    B_sub: np.ndarray, alpha: float = 1\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"`two_walk_laplacia(B_sub, alpha=1)`\n\n    Compute the two-walk Laplacian matrix of a bipartite graph.\n\n    For a bipartite graph with biadjacency matrix B, constructs the two-walk Laplacian\n    by first forming the two-walk adjacency matrix A_tw and then computing L_tw = D_tw - A_tw,\n    where D_tw is the diagonal degree matrix.\n\n    Parameters\n    ----------\n    B_sub : np.ndarray\n        Biadjacency matrix of shape (m, n) representing connections between two vertex sets\n    alpha : float, default=1.0\n        Scaling factor for the adjacency matrix term in the Laplacian computation\n\n    Returns\n    -------\n    L_tw : np.ndarray\n        Two-walk Laplacian matrix of shape (m+n, m+n)\n    Bsub_rows : np.ndarray\n        Indices of non-zero rows in the input matrix\n    Bsub_cols : np.ndarray\n        Indices of non-zero columns in the input matrix\n\n    Notes\n    -----\n    The two-walk adjacency matrix A_tw has the block structure:\n        [BB^T    \u03b1B  ]\n        [\u03b1B^T   B^TB ]\n\n    where \u03b1 is the scaling factor controlling the influence of direct connections.\n\n    The implementation automatically handles isolated vertices by removing rows/columns\n    with all zeros before computation. The returned indices enable mapping back to\n    the original matrix dimensions.\n\n    References\n    ----------\n    .. [1] Sun, X. (2024). Graph Algorithms for Matrix Analysis. CS521 Course Notes,\n           Duke University.\n\n    Examples\n    --------\n    &gt;&gt;&gt; B = np.array([[1, 0], [1, 1]])\n    &gt;&gt;&gt; L_tw, rows, cols = two_walk_laplacian(B)\n    &gt;&gt;&gt; print(L_tw.shape)\n    (4, 4)\n    \"\"\"\n    # Form the two-walk adjacency matrix with block structure\n    A_tw = np.block(\n        [[B_sub @ B_sub.T, alpha * B_sub], [alpha * B_sub.T, B_sub.T @ B_sub]]\n    )\n\n    # Compute degree matrix and Laplacian\n    D_tw = np.diag(np.sum(A_tw, axis=1))\n    L_tw = D_tw - A_tw\n\n    return L_tw\n</code></pre>"},{"location":"api/mosaic-heatmap.html","title":"<code>mosaic_heatmap</code>","text":"<p><code>mosaic_heatmap(data, ...)</code></p> <p>Plot mosaic data as a color-encoded matrix.</p> <p>Creates a mosaic heatmap where the column widths and row heights are proportional to the marginal sums of the data matrix. This provides a visualization that encodes both the cell values through color and the marginal distributions through cell sizes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>2D dataset that can be coerced into an ndarray. If a pandas DataFrame is provided, the index/column information will be used to label the columns and rows.</p> required <code>vmin</code> <code>float</code> <p>Values to anchor the colormap. If not provided, they are inferred from the data and other keyword arguments.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Values to anchor the colormap. If not provided, they are inferred from the data and other keyword arguments.</p> <code>None</code> <code>cmap</code> <code>str or Colormap</code> <p>The mapping from data values to color space. If not provided, the default depends on whether <code>center</code> is set.</p> <code>None</code> <code>center</code> <code>float</code> <p>The value at which to center the colormap for divergent data. Changes the default <code>cmap</code> if none is specified.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>If True and <code>vmin</code> or <code>vmax</code> are absent, compute colormap range using robust quantiles instead of extreme values.</p> <code>False</code> <code>annot</code> <code>bool or array - like</code> <p>If True, write the data value in each cell. If array-like with same shape as <code>data</code>, use this for annotation instead of the data. DataFrames match on position, not index.</p> <code>None</code> <code>fmt</code> <code>str</code> <p>String formatting code for annotation values. Default: '.2g'</p> <code>'.2g'</code> <code>annot_kws</code> <code>dict</code> <p>Keyword arguments for matplotlib.axes.Axes.text when <code>annot</code> is True.</p> <code>None</code> <code>linewidths</code> <code>float</code> <p>Width of cell divider lines. Default: 0</p> <code>0</code> <code>linecolor</code> <code>color</code> <p>Color of cell divider lines. Default: 'white'</p> <code>'white'</code> <code>cbar</code> <code>bool</code> <p>Whether to draw a colorbar. Default: True</p> <code>True</code> <code>cbar_kws</code> <code>dict</code> <p>Keyword arguments for matplotlib.figure.Figure.colorbar.</p> <code>None</code> <code>cbar_ax</code> <code>Axes</code> <p>Axes in which to draw the colorbar. If None, takes space from main Axes.</p> <code>None</code> <code>square</code> <code>bool</code> <p>If True, set aspect ratio to \"equal\" for square cells. Default: False</p> <code>False</code> <code>xticklabels</code> <code>'auto', bool, array-like, or int</code> <ul> <li>True: plot column/row names</li> <li>False: don't plot labels</li> <li>array-like: plot custom labels</li> <li>int: plot every nth label</li> <li>'auto': plot non-overlapping labels</li> </ul> <code>'auto'</code> <code>yticklabels</code> <code>'auto', bool, array-like, or int</code> <ul> <li>True: plot column/row names</li> <li>False: don't plot labels</li> <li>array-like: plot custom labels</li> <li>int: plot every nth label</li> <li>'auto': plot non-overlapping labels</li> </ul> <code>'auto'</code> <code>mask</code> <code>bool array or DataFrame</code> <p>If True in a cell, data is not shown. Missing values are auto-masked.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes in which to draw the plot. Uses current axes if None.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments passed to matplotlib.axes.Axes.pcolormesh.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The Axes object with the heatmap.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from mheatmap import mosaic_heatmap\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate sample confusion matrix data\n&gt;&gt;&gt; data = np.array([[10, 2, 0], [1, 8, 3], [0, 1, 12]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create mosaic heatmap with annotations\n&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))\n&gt;&gt;&gt; mosaic_heatmap(data, annot=True, cmap='YlOrRd', fmt='d',\n...               xticklabels=['A', 'B', 'C'],\n...               yticklabels=['A', 'B', 'C'])\n&gt;&gt;&gt; plt.title('Mosaic Confusion Matrix')\n&gt;&gt;&gt; plt.show()\n</code></pre> Notes <p>The mosaic heatmap is particularly useful for confusion matrices and contingency tables where the marginal distributions provide additional context beyond the cell values themselves.</p> Source code in <code>mheatmap/matrix.py</code> <pre><code>def mosaic_heatmap(\n    data,\n    *,\n    vmin=None,\n    vmax=None,\n    cmap=None,\n    center=None,\n    robust=False,\n    annot=None,\n    fmt=\".2g\",\n    annot_kws=None,\n    linewidths=0,\n    linecolor=\"white\",\n    cbar=True,\n    cbar_kws=None,\n    cbar_ax=None,\n    square=False,\n    xticklabels=\"auto\",\n    yticklabels=\"auto\",\n    mask=None,\n    ax=None,\n    **kwargs,\n):\n    \"\"\"`mosaic_heatmap(data, ...)`\n\n    Plot mosaic data as a color-encoded matrix.\n\n    Creates a mosaic heatmap where the column widths and row heights are proportional\n    to the marginal sums of the data matrix. This provides a visualization that\n    encodes both the cell values through color and the marginal distributions\n    through cell sizes.\n\n    Parameters\n    ----------\n    data : array-like\n        2D dataset that can be coerced into an ndarray. If a pandas DataFrame\n        is provided, the index/column information will be used to label the\n        columns and rows.\n    vmin, vmax : float, optional\n        Values to anchor the colormap. If not provided, they are inferred from the\n        data and other keyword arguments.\n    cmap : str or matplotlib.colors.Colormap, optional\n        The mapping from data values to color space. If not provided, the\n        default depends on whether ``center`` is set.\n    center : float, optional\n        The value at which to center the colormap for divergent data.\n        Changes the default ``cmap`` if none is specified.\n    robust : bool, optional\n        If True and ``vmin`` or ``vmax`` are absent, compute colormap range using\n        robust quantiles instead of extreme values.\n    annot : bool or array-like, optional\n        If True, write the data value in each cell. If array-like with same shape\n        as ``data``, use this for annotation instead of the data. DataFrames match\n        on position, not index.\n    fmt : str, optional\n        String formatting code for annotation values. Default: '.2g'\n    annot_kws : dict, optional\n        Keyword arguments for matplotlib.axes.Axes.text when ``annot`` is True.\n    linewidths : float, optional\n        Width of cell divider lines. Default: 0\n    linecolor : color, optional\n        Color of cell divider lines. Default: 'white'\n    cbar : bool, optional\n        Whether to draw a colorbar. Default: True\n    cbar_kws : dict, optional\n        Keyword arguments for matplotlib.figure.Figure.colorbar.\n    cbar_ax : matplotlib.axes.Axes, optional\n        Axes in which to draw the colorbar. If None, takes space from main Axes.\n    square : bool, optional\n        If True, set aspect ratio to \"equal\" for square cells. Default: False\n    xticklabels, yticklabels : 'auto', bool, array-like, or int, optional\n        - True: plot column/row names\n        - False: don't plot labels\n        - array-like: plot custom labels\n        - int: plot every nth label\n        - 'auto': plot non-overlapping labels\n    mask : bool array or DataFrame, optional\n        If True in a cell, data is not shown. Missing values are auto-masked.\n    ax : matplotlib.axes.Axes, optional\n        Axes in which to draw the plot. Uses current axes if None.\n    **kwargs : dict\n        Additional keyword arguments passed to matplotlib.axes.Axes.pcolormesh.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The Axes object with the heatmap.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; from mheatmap import mosaic_heatmap\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Generate sample confusion matrix data\n    &gt;&gt;&gt; data = np.array([[10, 2, 0], [1, 8, 3], [0, 1, 12]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create mosaic heatmap with annotations\n    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))\n    &gt;&gt;&gt; mosaic_heatmap(data, annot=True, cmap='YlOrRd', fmt='d',\n    ...               xticklabels=['A', 'B', 'C'],\n    ...               yticklabels=['A', 'B', 'C'])\n    &gt;&gt;&gt; plt.title('Mosaic Confusion Matrix')\n    &gt;&gt;&gt; plt.show()\n\n    Notes\n    -----\n    The mosaic heatmap is particularly useful for confusion matrices and contingency\n    tables where the marginal distributions provide additional context beyond the\n    cell values themselves.\n    \"\"\"\n    # Initialize the _MosaicHeatMapper class\n    plotter = _MosaicHeatMapper(\n        data,\n        vmin,\n        vmax,\n        cmap,\n        center,\n        robust,\n        annot,\n        fmt,\n        annot_kws,\n        cbar,\n        cbar_kws,\n        xticklabels,\n        yticklabels,\n        mask,\n    )\n\n    # Add the linewidths and linecolor kwargs\n    # kwargs[\"linewidths\"] = linewidths\n    # kwargs[\"linecolor\"] = linecolor\n\n    # Draw the plot and return the Axes\n    if ax is None:\n        ax = plt.gca()\n    if square:\n        ax.set_aspect(\"equal\")\n    plotter.plot(ax, cbar_ax, kwargs)\n    return ax\n</code></pre>","boost":2},{"location":"api/rms-permute.html","title":"<code>rms_permute</code>","text":"<p><code>rms_permute(confusion_matrix, labels)</code></p> <p>Perform reverse merge/split (RMS) permutation analysis on a confusion matrix.</p> <p>This function analyzes and permutes a confusion matrix to identify merge and split relationships between predicted and ground truth labels. A merge relationship occurs when multiple ground truth labels map to the same predicted label, while a split relationship occurs when a single ground truth label maps to multiple predicted labels.</p> <p>Parameters:</p> Name Type Description Default <code>confusion_matrix</code> <code>ndarray</code> <p>The confusion matrix to analyze, shape (n_classes, n_classes)</p> required <code>labels</code> <code>ndarray</code> <p>The labels corresponding to the confusion matrix rows/columns, shape (n_classes,)</p> required <p>Returns:</p> Name Type Description <code>permuted_matrix</code> <code>ndarray</code> <p>The confusion matrix after permuting rows and columns to group related labels</p> <code>permuted_labels</code> <code>ndarray</code> <p>The reordered labels corresponding to the permuted matrix</p> <code>rms_label_map</code> <code>dict</code> <p>Dictionary mapping predicted labels to tuples of (ground truth label, relationship type)</p> <code>rms_map_matrix</code> <code>ndarray</code> <p>Matrix representation of merge/split relationships between labels</p> <code>rms_map_type</code> <code>ndarray</code> <p>Array of relationship types ('rmerge' or 'rsplit') for each relationship</p> See Also <p>mheatmap.amc_postprocess : Related module for confusion matrix post-processing mheatmap.spectral_permute : Alternative permutation method using spectral ordering</p> Notes <p>The function identifies two types of label relationships: - Merge (rmerge): Multiple ground truth labels map to same predicted label - Split (rsplit): Single ground truth label maps to multiple predicted labels</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; conf_mat = np.array([[2, 1, 0], [0, 3, 1], [1, 0, 2]])\n&gt;&gt;&gt; labels = np.array([1, 2, 3])\n&gt;&gt;&gt; perm_mat, perm_labs, rmap, rmat, rtypes = rms_permute(conf_mat, labels)\n</code></pre> Source code in <code>mheatmap/_rms_permute.py</code> <pre><code>def rms_permute(confusion_matrix: np.ndarray, labels: np.ndarray) -&gt; tuple:\n    \"\"\"`rms_permute(confusion_matrix, labels)`\n\n    Perform reverse merge/split (RMS) permutation analysis on a confusion matrix.\n\n    This function analyzes and permutes a confusion matrix to identify merge and split\n    relationships between predicted and ground truth labels. A merge relationship occurs\n    when multiple ground truth labels map to the same predicted label, while a split\n    relationship occurs when a single ground truth label maps to multiple predicted labels.\n\n    Parameters\n    ----------\n    confusion_matrix : numpy.ndarray\n        The confusion matrix to analyze, shape (n_classes, n_classes)\n    labels : numpy.ndarray\n        The labels corresponding to the confusion matrix rows/columns, shape (n_classes,)\n\n    Returns\n    -------\n    permuted_matrix : numpy.ndarray\n        The confusion matrix after permuting rows and columns to group related labels\n    permuted_labels : numpy.ndarray\n        The reordered labels corresponding to the permuted matrix\n    rms_label_map : dict\n        Dictionary mapping predicted labels to tuples of (ground truth label, relationship type)\n    rms_map_matrix : numpy.ndarray\n        Matrix representation of merge/split relationships between labels\n    rms_map_type : numpy.ndarray\n        Array of relationship types ('rmerge' or 'rsplit') for each relationship\n\n    See Also\n    --------\n    mheatmap.amc_postprocess : Related module for confusion matrix post-processing\n    mheatmap.spectral_permute : Alternative permutation method using spectral ordering\n\n    Notes\n    -----\n    The function identifies two types of label relationships:\n    - Merge (rmerge): Multiple ground truth labels map to same predicted label\n    - Split (rsplit): Single ground truth label maps to multiple predicted labels\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; conf_mat = np.array([[2, 1, 0], [0, 3, 1], [1, 0, 2]])\n    &gt;&gt;&gt; labels = np.array([1, 2, 3])\n    &gt;&gt;&gt; perm_mat, perm_labs, rmap, rmat, rtypes = rms_permute(conf_mat, labels)\n    \"\"\"\n    rms = _RMSPermute(confusion_matrix, labels)\n    permuted_matrix = rms.get_permuted_matrix()\n    permuted_labels = rms.get_permuted_labels()\n    rms_label_map = rms.rms_label_map\n    rms_map_matrix, rms_map_type = rms.get_rms_map_matrix()\n\n    return permuted_matrix, permuted_labels, rms_label_map, rms_map_matrix, rms_map_type\n</code></pre>"},{"location":"examples/index.html","title":"mheatmap Examples","text":"<p>This directory contains example scripts demonstrating the usage of mheatmap package.</p> <ul> <li><code>basic_usage.py</code>: Simple examples of basic functionality</li> <li><code>advanced_features.py</code>: Shows advanced features like AMC post-processing and spectral reordering</li> </ul>"},{"location":"examples/mosaic_heatmap.html","title":"Mosaic Heatmap","text":""},{"location":"examples/mosaic_heatmap.html#importing-packages","title":"Importing Packages","text":"<pre><code>import matplotlib.pyplot as plt\n\nimport numpy as np\nimport seaborn as sns\nfrom src.mheatmap import mosaic_heatmap\n</code></pre>"},{"location":"examples/mosaic_heatmap.html#example","title":"Example","text":"<pre><code># Create a sample 4x4 confusion matrix with some interesting patterns\nconf_mat = np.array([\n    [85, 10, 5,   0],  # High accuracy for class 0 \n    [0,  50, 30,  0],  # Some confusion between classes 1 and 2\n    [0,   0,  0,  0],  # Empty row representing unused class\n    [0,   0,  0, 100]  # Perfect classification for class 3\n])\n\n# Create a figure with two subplots side by side\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\n# Plot traditional heatmap using seaborn\nsns.heatmap(conf_mat, annot=False, fmt=\"d\", cmap=\"YlGnBu\", ax=ax1)\nax1.set_title(\"Normal Heatmap\", fontsize=18, color='#4A4A4A')  # Medium gray\nax1.xaxis.set_ticks_position('top')\nax1.tick_params(colors='#4A4A4A')\n\n# Plot mosaic heatmap using mheatmap\nmosaic_heatmap(conf_mat, annot=False, fmt=\"d\", cmap=\"YlGnBu\", ax=ax2)\nax2.set_title(\"Mosaic Heatmap\", fontsize=18, color='#4A4A4A')  # Medium gray\nax2.xaxis.set_ticks_position('top')\nax2.tick_params(colors='#4A4A4A')\n\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/rms_permute.html","title":"RMS Permutation Demo","text":""},{"location":"examples/rms_permute.html#importing-packages","title":"Importing Packages","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom src.mheatmap import (\n    amc_postprocess, \n    rms_permute, \n    mosaic_heatmap\n)\nimport matplotlib.pyplot as plt\nimport scipy\nimport warnings\n</code></pre>"},{"location":"examples/rms_permute.html#load-data","title":"Load Data","text":"<ul> <li>Load the ground truth labels</li> <li><code>Salinas_gt.mat</code>: Ground truth labels for Salinas dataset</li> <li>Load the predicted labels from <code>spectral clustering</code></li> </ul> <pre><code># Load the data\ny_true = scipy.io.loadmat(\"data/Salinas_gt.mat\")[\"salinas_gt\"].reshape(-1)\n# Load predicted labels from spectral clustering\ny_pred = np.array(\n    pd.read_csv(\n        \"data/Salinas_spectralclustering.csv\",\n        header=None,\n        low_memory=False,\n    )\n    .values[1:]\n    .flatten()\n)\nprint(f\"y_true shape: {y_true.shape}\")\nprint(f\"y_pred shape: {len(y_pred)}\")\n</code></pre> <pre><code>    y_true shape: (111104,)\n    y_pred shape: 111104\n</code></pre>"},{"location":"examples/rms_permute.html#amc-post-processing","title":"AMC Post-processing","text":"<ul> <li>Alignment with <code>Hungarian</code> algorithm</li> <li>Masking the zeros (unlabeled pixels) with <code>mask_zeros_from_gt</code></li> <li>Computing the confusion matrix</li> </ul> <p>See <code>AMC Post-processing</code> for more details.</p> <pre><code># AMC post-processing\n_, conf_mat, labels = amc_postprocess(y_pred, y_true)\n</code></pre>"},{"location":"examples/rms_permute.html#rms-permutation","title":"RMS Permutation","text":"<ul> <li>Reverse Merge/Split Idea:</li> <li>Merge: \\(GT0, GT1 \\rightarrow PRD0, PRD0\\)</li> <li>Split: \\(GT0, GT0 \\rightarrow PRD0, PRD1\\)</li> <li>Which impact OA or AA metrics but not ARI (<code>resolution issue</code>)</li> </ul> <pre><code># Demonstrate RMS permutation analysis\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", category=RuntimeWarning)\n    rms_C, rms_labels, _, rms_map_matrix, rms_map_type = rms_permute(conf_mat, labels)\n</code></pre>"},{"location":"examples/rms_permute.html#visualize-the-results","title":"Visualize the results","text":"<pre><code># Visualize original vs RMS permuted matrices\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\nmosaic_heatmap(conf_mat, ax=ax1, xticklabels=labels, yticklabels=labels, cmap=\"YlGnBu\")\nax1.set_title(\"Original\", fontsize=18, color='#4A4A4A')  # Medium gray\nax1.tick_params(colors='#4A4A4A')\n\nmosaic_heatmap(\n    rms_C, ax=ax2, xticklabels=rms_labels, yticklabels=rms_labels, cmap=\"YlGnBu\"\n)\nax2.set_title(\"RMS Permuted\", fontsize=18, color='#4A4A4A')  # Medium gray\nax2.xaxis.set_ticks_position('top')\nax2.tick_params(colors='#4A4A4A')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/rms_permute.html#rms-matrix-visualization","title":"RMS Matrix Visualization","text":"<pre><code>import seaborn as sns\n\nfig, ax = plt.subplots(figsize=(10, 10))\nsns.heatmap(\n    rms_map_matrix, \n    annot=True, \n    annot_kws={\"size\": 18},\n    cbar=False,\n    cmap=\"YlGnBu\",\n    xticklabels=['GT1', 'GT2', 'PRED1', 'PRED2'],\n    yticklabels=rms_map_type\n)\nax.set_title(\"RMS Matrix\", fontsize=18, color='#4A4A4A')  # Medium gray\nax.tick_params(colors='#4A4A4A', axis='both', which='major', labelsize=18)\nax.axvline(x=2, color='black', linewidth=2)\nplt.tight_layout()\nplt.savefig(\"rms_matrix.png\", dpi=300, transparent=True)\nplt.show()\n</code></pre>"},{"location":"examples/spectral_permute.html","title":"Spectral Permutation Demo","text":""},{"location":"examples/spectral_permute.html#importing-packages","title":"Importing Packages","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom mheatmap import (\n    amc_postprocess,  \n    mosaic_heatmap\n)\nfrom mheatmap.graph import spectral_permute\nfrom mheatmap.constants import set_test_mode\n\nset_test_mode(True)\n\nimport matplotlib.pyplot as plt\nimport scipy\n</code></pre>"},{"location":"examples/spectral_permute.html#load-data","title":"Load Data","text":"<ul> <li> <p>Load the ground truth labels</p> <ul> <li><code>Salinas_gt.mat</code>: Ground truth labels for Salinas dataset</li> </ul> </li> <li> <p>Load the predicted labels from <code>spectral clustering</code></p> </li> </ul> <pre><code># Load the data\ny_true = scipy.io.loadmat(\"data/Salinas_gt.mat\")[\"salinas_gt\"].reshape(-1)\n# Load predicted labels from spectral clustering\ny_pred = np.array(\n    pd.read_csv(\n        \"data/Salinas_spectralclustering.csv\",\n        header=None,\n        low_memory=False,\n    )\n    .values[1:]\n    .flatten()\n)\nprint(f\"y_true shape: {y_true.shape}\")\nprint(f\"y_pred shape: {len(y_pred)}\")\n</code></pre> <pre><code>y_true shape: (111104,)\ny_pred shape: 111104\n</code></pre>"},{"location":"examples/spectral_permute.html#amc-post-processing","title":"AMC Post-processing","text":"<ul> <li>Alignment with <code>Hungarian</code> algorithm</li> <li>Masking the zeros (unlabeled pixels) with mask_zeros_from_gt</li> <li>Computing the confusion matrix</li> </ul> <p>See AMC Post-processing for more details.</p> <pre><code># AMC post-processing\n_, conf_mat, labels = amc_postprocess(y_pred, y_true)\n</code></pre>"},{"location":"examples/spectral_permute.html#spectral-permutation","title":"Spectral Permutation","text":"<ul> <li>Treat the confusion matrix as an adjacency matrix</li> </ul> \\[ A = C \\] <ul> <li>Compute the graph Laplacian</li> </ul> \\[ L = D - A \\] <ul> <li>Compute the eigenvectors and eigenvalues</li> </ul> \\[ L = U \\Sigma U^T \\] <ul> <li>Sort the eigenvectors based on the eigenvalues</li> </ul> \\[ U = [u_1, u_2, \\ldots, u_n] \\] <ul> <li>Fiedler vector is the second smallest eigenvector</li> </ul> \\[ f = u_2 \\] <ul> <li>Sort the labels based on the Fiedler vector</li> </ul> \\[ \\pi\\tilde{y} = \\tilde{y}[f] \\] <ul> <li>Reorder the confusion matrix based on the sorted labels</li> </ul> \\[ \\pi C = C[f, f] \\] <pre><code># spectral reordering\nreordered_mat, reordered_labels = spectral_permute(conf_mat, labels)\n</code></pre>"},{"location":"examples/spectral_permute.html#visualize-the-results","title":"Visualize the Results","text":"<pre><code># Visualize original vs spectrally reordered matrices\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\nmosaic_heatmap(conf_mat, ax=ax1, xticklabels=labels, yticklabels=labels, cmap=\"YlGnBu\")\nax1.set_title(\"Original\", fontsize=18, color='#4A4A4A')  # Medium gray\nax1.xaxis.set_ticks_position('top')\nax1.tick_params(colors='#4A4A4A')\n\nmosaic_heatmap(\n    reordered_mat,\n    ax=ax2,\n    xticklabels=reordered_labels,\n    yticklabels=reordered_labels,\n    cmap=\"YlGnBu\",\n)\nax2.set_title(\"Spectral Reordered\", fontsize=18, color='#4A4A4A')  # Medium gray\nax2.xaxis.set_ticks_position('top')\nax2.tick_params(colors='#4A4A4A')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/spectral_permute.html#two-walk-spectral-permutation","title":"Two-walk Spectral Permutation","text":"<pre><code># Two-walk Laplacian\nreordered_mat, reordered_labels = spectral_permute(conf_mat, labels, mode='tw')\n</code></pre>"},{"location":"examples/spectral_permute.html#visualize-the-tw-results","title":"Visualize the TW Results","text":"<pre><code># Visualize original vs spectrally reordered matrices\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\nmosaic_heatmap(conf_mat, ax=ax1, xticklabels=labels, yticklabels=labels, cmap=\"YlGnBu\")\nax1.set_title(\"Original\", fontsize=18, color='#4A4A4A')  # Medium gray\nax1.xaxis.set_ticks_position('top')\nax1.tick_params(colors='#4A4A4A')\n\nmosaic_heatmap(\n    reordered_mat,\n    ax=ax2,\n    xticklabels=reordered_labels,\n    yticklabels=reordered_labels,\n    cmap=\"YlGnBu\",\n)\nax2.set_title(\"TW Spectral Reordered\", fontsize=18, color='#4A4A4A')  # Medium gray\nax2.xaxis.set_ticks_position('top')\nax2.tick_params(colors='#4A4A4A')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/index.html","title":"User Guide","text":""},{"location":"user-guide/index.html#introduction","title":"Introduction","text":"<p>mheatmap is a Python package for advanced heatmap visualization and matrix analysis.</p> <p>It provides tools for:</p> <ul> <li>Creating proportional/mosaic heatmaps</li> <li>AMC post-processing of confusion matrices</li> <li>Spectral permutation analysis</li> <li>RMS (Reverse Merge/Split) permutation analysis</li> </ul>"},{"location":"user-guide/index.html#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/index.html#mosaic-heatmap","title":"Mosaic Heatmap","text":"<p>The mosaic heatmap is a novel visualization where cell sizes are proportional to their row and column sums:</p> <pre><code>import numpy as np\nfrom mheatmap import mosaic_heatmap\n\nconf_mat = np.array([\n    [85, 10,  5],\n    [15, 70, 15],\n    [ 5, 20, 75]\n])\n\nmosaic_heatmap(conf_mat, \n               annot=True,    # (1)!\n               fmt='d',       # (2)!\n               cmap='YlOrRd') # (3)!\n</code></pre> <ol> <li>Show values in cells</li> <li>Format as integers</li> <li>Use Yellow-Orange-Red colormap</li> </ol>"},{"location":"user-guide/index.html#amc-post-processing","title":"AMC Post-processing","text":"<p>AMC (Align-Mask-Confusion) is a technique for post-processing confusion matrices or to say pre-processing before mosaic heatmap visualization:</p> \\[ C_{masked} = C_{raw} \\odot M, \\quad \\text{where } \\odot \\text{ is the element-wise multiplication} \\] \\[ \\Pi = \\underset{\\pi}{\\arg\\min} \\sum_{i,j} C_{masked}[i,\\Pi(j)], \\quad \\text{where } \\Pi \\text{ is a permutation matrix} \\] \\[ \\tilde{y} = \\Pi \\cdot \\hat{y} \\] \\[ \\tilde{C} = \\Pi \\cdot C_{masked} \\] \\[ \\tilde{l} = \\Pi \\cdot l \\] <pre><code>from mheatmap import amc_postprocess\n\naligned_pred, processed_mat, processed_labels = amc_postprocess(conf_mat, labels)\n</code></pre>"},{"location":"user-guide/index.html#spectral-reordering","title":"Spectral Reordering","text":"<p>Reorder matrices based on spectral analysis:</p> <p>Note: see <code>examples</code> for more details.</p> <pre><code>from mheatmap import spectral_permute\n\nreordered_mat, reordered_labels = spectral_permute(conf_mat, labels)\n</code></pre>"},{"location":"user-guide/index.html#rms-permutation-analysis","title":"RMS Permutation Analysis","text":"<p>RMS (Reverse Merge/Split) analysis helps identify merge and split relationships in matrices:</p> <p>Note: see <code>examples</code> for more details.</p> <pre><code>from mheatmap import rms_permute\n\nreordered_mat, reordered_labels, rms_mapping = rms_permute(conf_mat, labels)\n</code></pre>"},{"location":"user-guide/index.html#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"user-guide/index.html#memory-efficiency","title":"Memory Efficiency","text":"<p>For large matrices:</p> <pre><code>from scipy import sparse\nsparse_mat = sparse.csr_matrix(large_matrix) # (1)!\nmosaic_heatmap(sparse_mat, ...)\n</code></pre> <ol> <li>Use sparse matrices for efficiency</li> </ol>"},{"location":"user-guide/index.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Use <code>numpy</code> arrays instead of lists</li> <li>Pre-compute reusable values</li> <li>Use sparse matrices for large, sparse data</li> <li>Consider downsampling for visualization of very large matrices</li> </ol>"},{"location":"user-guide/index.html#references","title":"References","text":"<ol> <li>Confusion Matrix Visualization Paper</li> <li>AMC Post-processing Algorithm</li> <li>Spectral Reordering</li> <li>RMS Permutation Analysis</li> </ol>"}]}